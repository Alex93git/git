# Регистрация и Настройка Git на Mac

Эта инструкция поможет вам зарегистрироваться на GitHub, установить Git и настроить его на Mac. Следуйте шагам ниже:

## Шаг 1: Регистрация на GitHub

1. Перейдите на сайт [GitHub](https://github.com/).
2. Нажмите на кнопку **Sign up** в правом верхнем углу.
3. Заполните форму регистрации:
    - Введите ваш email.
    - Создайте и введите пароль.
    - Придумайте и введите имя пользователя.
4. Нажмите **Create account**.
5. Следуйте инструкциям на экране для завершения регистрации (проверка email и т.д.).

## Шаг 2: Установка Git

### С помощью Homebrew

1. Установите Homebrew, если он еще не установлен. Откройте Terminal и выполните следующую команду:
    ```sh
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ```
2. Установите Git с помощью Homebrew:
    ```sh
    brew install git
    ```

### С помощью Git Installer

1. Перейдите на [сайт Git](https://git-scm.com/download/mac).
2. Скачайте последнюю версию Git.
3. Откройте загруженный файл и следуйте инструкциям установщика.

## Шаг 3: Проверка установки

После установки откройте Terminal и выполните следующую команду, чтобы проверить установленную версию Git:
```sh
git --version
```
Вы должны увидеть что-то вроде:
```
git version 2.x.x
```

## Шаг 4: Настройка Git

1. Откройте Terminal.
2. Настройте ваше имя пользователя:
    ```sh
    git config --global user.name "Ваше Имя"
    ```
3. Настройте ваш email:
    ```sh
    git config --global user.email "ваш.email@example.com"
    ```
4. Проверьте настройки, выполнив:
    ```sh
    git config --list
    ```

## Шаг 5: Генерация SSH ключа (опционально, но рекомендуется)

1. Проверьте, есть ли у вас уже SSH ключи:
    ```sh
    ls -al ~/.ssh
    ```
2. Если ключей нет, создайте новый:
    ```sh
    ssh-keygen -t ed25519 -C "ваш.email@example.com"
    ```
   Следуйте инструкциям на экране, оставляя настройки по умолчанию.

3. Добавьте SSH ключ в ssh-agent:
    ```sh
    eval "$(ssh-agent -s)"
    ssh-add -K ~/.ssh/id_ed25519
    ```
4. Скопируйте SSH ключ в буфер обмена:
    ```sh
    pbcopy < ~/.ssh/id_ed25519.pub
    ```
5. Перейдите в настройки вашего аккаунта на GitHub:
    - Нажмите на ваш аватар в правом верхнем углу и выберите **Settings**.
    - В меню слева выберите **SSH and GPG keys**.
    - Нажмите **New SSH key**, вставьте ключ из буфера обмена и нажмите **Add SSH key**.

## Шаг 6: Клонирование репозитория

1. Найдите репозиторий на GitHub, который хотите клонировать.
2. Нажмите кнопку **Code** и скопируйте SSH URL.
3. В Terminal выполните команду:
    ```sh
    git clone git@github.com:username/repository.git
    ```

Теперь вы успешно настроили Git на вашем Mac и можете начинать работу с репозиториями!



1. Добавьте в шпаргалку основную информацию из уроков о хеше, логе, `HEAD`, статусах файлов и оформлении сообщений к коммитам.



## Хеш — идентификатор коммита

В процессе работы с Git вам будет часто встречаться понятие «хеш коммита». Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду `git log` и выводили историю коммитов.

![image](https://github.com/Alex93git/git/blob/0cc1083fd523f25f2ba0c1a2b1063819eb70a0c2/Image.png)

### Что такое хеш. Хеширование коммитов

**Хеширование** (от англ. *hash*, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. *fingerprint*).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или **родительский** (англ. *parent*), коммит.

Git хеширует (преобразует) информацию о коммите с помощью алгоритма **SHA-1** (от англ. ***S**ecure **H**ash **A**lgorithm* — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный **хеш** — результат хеширования.

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Чтобы убедиться в этом, можно поэкспериментировать с SHA-1 [на этом сайте](https://emn178.github.io/online-tools/sha1.html) — попробуйте ввести в поле **input** (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле **output** (англ. «вывод»).

### Хеш — основной идентификатор коммита

Git хранит таблицу соответствий `хеш → информация о коммите`. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши встречаются регулярно. Их можно передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

Все хеши и таблицу `хеш → информация о коммите` Git сохраняет в служебные файлы. Они находятся в скрытой папке `.git` в репозитории проекта.



## Лог - список изменений проекта

рассмотрим подробнее, из каких элементов состоит описание коммита, а также как вывести сокращённый **лог** (от англ. *log* — «журнал [записей]»). Сокращённый лог полезен, если нужно быстро найти нужный коммит среди сотни других.

### Элементы описания коммита

После вызова `git log` появляется список коммитов.

![](https://github.com/Alex93git/git/blob/0cc1083fd523f25f2ba0c1a2b1063819eb70a0c2/Image-2.png)

Элементы, из которых состоит описание:

- строка из цифр и латинских букв после слова **commit** — это хеш коммита;
- **Author** — имя автора и его электронная почта;
- **Date** — дата и время создания коммита;
- в конце находится сообщение коммита.

### Получить сокращённый лог — `git log --oneline`

Получить сокращённый лог можно с помощью команды `git log` с флагом `--oneline` (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

![](https://github.com/Alex93git/git/blob/0cc1083fd523f25f2ba0c1a2b1063819eb70a0c2/Image-3.png)

Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.

Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

💡 Самое важное:

- Можно вызвать не только полный лог, но и сокращённый — это делается командой `git log --oneline`.
- В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.

## **HEAD** — указатель на текущий коммит в Git. 

При вызове команды `git log` возникает надпись `(HEAD -> master)` после хеша одного из коммитов. Ниже подробно рассмотрим о чем идет речь.

![](https://github.com/Alex93git/git/blob/0cc1083fd523f25f2ba0c1a2b1063819eb70a0c2/Image-4.png)

### Файл `HEAD`

Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

В этом можно убедиться с помощью терминала. Перейдите в папку `.git` командой `cd`. Посмотрите содержимое файла `HEAD` командой `cat`.

```
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка 
```

Внутри `HEAD` — ссылка на служебный файл: `refs/heads/master` (или `refs/heads/main` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

```
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты 
```

Когда вы делаете коммит, Git обновляет `refs/heads/master` — записывает в него хеш последнего коммита. Получается, что `HEAD` тоже обновляется, так как ссылается на `refs/heads/master`.



## Статусы файлов в Git

До появления Git системы контроля версий выделяли только два статуса у файлов: «уже закоммичен» и «ещё не закоммичен». Например, в Subversion (самой популярной VCS до эпохи Git) не нужно было выполнять команду — аналог `git add`, а можно было просто сделать коммит (`svn commit`). Эта команда по умолчанию добавляла в коммит все новые и изменённые файлы.

Такое поведение интуитивно более понятно. Зато Git даёт больше контроля за состоянием файлов. 

### Статусы `untracked`/`tracked`, `staged` и `modified`

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

- **`untracked`** (англ. «неотслеживаемый») 
  Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`. 

- **`staged`** (англ. «подготовленный»)

    После выполнения команды `git add` файл попадает в **staging area** (от англ. *stage* — «сцена», «этап [процесса]» и *area* — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.

- **`tracked`** (англ. «отслеживаемый») 
  Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в staging area командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения. 

- **`modified`** (англ. «изменённый») 
  Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

💡 Для файлов в состояниях `staged` и `modified` обычно не указывают, что они также `tracked`, потому что это состояние подразумевается.

### Про `staged` и `modified`

Команда `git add` добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете `git add file.txt`, а затем измените `file.txt`, то новое содержимое файла не будет находиться в staging.

Git сообщит об этом с помощью статуса `modified`: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить `git add file.txt` ещё раз.

### Типичный жизненный цикл файла в Git

Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.

![](https://github.com/Alex93git/git/blob/0cc1083fd523f25f2ba0c1a2b1063819eb70a0c2/Image-5.png)

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2. Файл добавили в staging area с помощью git add. Состояние: `staged` (+ `tracked`). 

   - Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`). Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий.

   - Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).
3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.
4. Изменили файл. Состояние: `modified` (+ `tracked`).
5. Снова добавили в staging area с помощью `git add`. Состояния: `staged` (+ `tracked`).
6. Сделали коммит. Состояния: `tracked`.

💡Важное:

- Статусом `untracked` помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность `tracked`, в который попадают все файлы, отслеживаемые Git.
- Файл переходит в статус `staged` после выполнения `git add`.
- Статус `modified` означает, что файл был изменён.
- Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

## Оформление сообщений к коммитам

То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями.

Например, в выводе команды `git log --oneline` умещается максимум 7272 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 7272 символов».

В этом уроке рассмотрим несколько популярных подходов к оформлению сообщений коммитов. Но сначала разберём, почему такие сообщения важны и зачем соблюдать правила их оформления.

### Зачем вообще писать сообщения

У каждого коммита в Git есть сообщение — то, что передаётся после параметра `-m`. Например: `git commit -m "Добавить урок про оформление сообщений коммитов"`.

Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.

Как и надпись на коробке, сообщение коммита должно помочь определить, что внутри. Например, надпись на коробке «всякое разное» не очень полезная. Сообщение коммита «небольшие исправления» тоже: непонятно, что было исправлено в таком коммите и зачем.

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

- относительно коротким, чтобы его было легко прочитать;
- информативным.

Вот пример полезного сообщения в репозитории новостного сайта: `Исправление опечатки в заголовке главной страницы на хорватском`. Такое сообщение даёт много информации:

- `Исправление опечатки` значит, что исправлена ошибка, которая была допущена при наборе. Такое исправление не меняет смысл. То есть, например, главному редактору не нужно перепроверять этот заголовок.
- `На хорватском` говорит о том, что переводчикам на другие языки этот коммит можно смело пропускать.
- `В заголовке главной страницы` указывает, где произошли изменения. Если, например, кто-то зайдёт на сайт и ему не понравится новый заголовок, он легко найдёт по истории (`git log`) автора этого коммита и спросит у него, почему заголовок теперь такой.

Пример плохого сообщения для того же коммита: `Исправлена опечатка`. Это сообщение даёт мало информации. В такой коммит придётся «заглядывать» — разбираться, что именно поменялось и зачем.

### Стили оформления

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: `Исправить сообщение об ошибке E123`, кто-то — глаголы в прошедшем времени: `Исправил…`, кто-то — существительные: `Исправление…`.

Без единообразия коммитов нет и эффективной работы в Git. Это может показаться мелочью, но когда коммиты с сообщениями в разных стилях идут друг за другом, их может быть сложно читать.

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.

Например, правила могут быть такие:

- длина сообщения от 3030 до 7272 символов;
- первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);
- и так далее.

Есть много подходов к оформлению сообщений коммитов, но мы расскажем о нескольких популярных. Их используют как отдельные команды, так и целые проекты.

### Корпоративный

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, `LGS-239` значит, что это 239239-я задача в проекте **LGS** (сокращение от англ. ***l**o**g**istic**s*** — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

```
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами" 
```

Какие-то команды могут договариваться, с какой части речи начинать сообщение и какой длины оно должно быть, какие-то — нет. Но требование о наличии Jira-ID обычно строгое: оно позволяет автоматически связывать коммиты с задачами и проектами.

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.

Conventional Commits предлагает такой формат коммита: `<type>: <сообщение>`. Первая часть `type` — это тип изменений. Таких типов достаточно много. Вот два примера:

- `feat` (сокращение от англ. *feature*) — для новой функциональности;
- `fix` (от англ. «исправить», «устранить») — для исправленных ошибок.

Более подробный список можно увидеть [на сайте с описанием этого стиля](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#спецификация).

Например, сообщение может быть таким.

```
git commit -m "feat: добавить подсчёт суммы заказов за неделю" 
```

### GitHub-стиль

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка **задач** (англ. *issue*) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать `#<номер задачи>`. Например, вот так.

```
$ git commit -m "Исправить #334, добавить график температуры" 
```

В таком случае GitHub свяжет коммит и задачу.



💡 **Инфинитив и императив**

Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: `Добавить тесты для PipkaService`, `Исправить ошибку #123` и так далее.

Для сообщений на английском рекомендуется использовать **повелительное наклонение** (англ. *imperative*). Например: `Use library mega_lib_300`, `Fix exit button` и так далее.

Эти рекомендации сложились исторически, и им следуют многие проекты.

